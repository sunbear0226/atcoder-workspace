#!/usr/bin/env python3
import sys

MOD = 1000000007  # type: int


def solve(n: int, a: int, b: int):
    # 1本選ぶ時→nC1、2本選ぶ時→nC2、...、n本選ぶ時→nCn
    # 二項定理の和の公式より、上記の和はnC1+nC2+...+nCn=2**n
    # ans=2**n-1-nCa-nCb # 「-1」は、0本選ぶ場合を除外している。(問題の制限がN>=1なので)
    # 数列nCaの総和 = ΣnCa = n/1 + n(n-1)/2*1 + n(n-1)(n-2)/3*2*1 + ... + n(n-1)(n-2)...(n-a+1)/a!
    # ΣnCa = Π(n-a)/a! # Π(パイ)は総乗(数列を掛け算した合計)のこと。Σ(シグマ)は総和。
    # 2**nは普通に**で求めるとTLEする。python3ならpow()を使用することでO(logn)で計算できる。「繰り返し二乗法」という。
    # 繰返し二乗法・・・f(x) = 2**x、f(2x) = f(x)**2、f(2x+1) = f(x)**2 * 2、f(N) = f(2/N)**2
    nCa = comb(n, a)
    nCb = comb(n, b)
    ans = (pow(2, n, MOD) - 1 - nCa - nCb) % MOD
    print(int(ans))


def comb(n, a):
    x = y = 1  # xが分子、yが分母
    for i in range(a):
        x *= n - i
        x %= MOD
        y *= i + 1
        y %= MOD
    # 割り算はコストが高いので,x/yするとTLEする。
    # mod pの結果が素数の場合は、フェルマーの小定理でx≡x**(p) mod p (pを法として合同)となる。
    # ここから逆元(逆数)を求めると、1/x = x**(p)/x**2 = x**(p-2)となる。(なお、合同式で両辺を割る事が出来るのは、xとpが互いに素の場合のみ)
    return x * pow(y, MOD-2, MOD) % MOD


# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    n = int(next(tokens))  # type: int
    a = int(next(tokens))  # type: int
    b = int(next(tokens))  # type: int
    solve(n, a, b)

if __name__ == '__main__':
    main()
